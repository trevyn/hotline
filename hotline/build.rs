use std::env;
use std::fs;
use std::path::Path;

fn main() {
    // Only run when monolith feature is enabled
    if env::var("CARGO_FEATURE_MONOLITH").is_ok() {
        println!("cargo:rerun-if-changed=../objects/");
        
        let out_dir = env::var("OUT_DIR").unwrap();
        let dest_path = Path::new(&out_dir).join("monolith_objects.rs");
        
        let mut generated = String::new();
        
        // Generate module with all object implementations
        generated.push_str("// Auto-generated by build.rs - DO NOT EDIT\n\n");
        
        // Process rect object
        let rect_src = fs::read_to_string("../objects/rect/src/lib.rs")
            .expect("Failed to read rect source");
        
        // Find where the actual object definition ends (before extern functions)
        let rect_lines: Vec<&str> = rect_src.lines().collect();
        let mut end_index = rect_lines.len();
        
        // Find the first extern function
        for (i, line) in rect_lines.iter().enumerate() {
            if line.contains("#[unsafe(no_mangle)]") || line.contains("pub extern") {
                end_index = i;
                break;
            }
        }
        
        // Take only the object definition part
        let rect_def = rect_lines[..end_index].join("\n");
        
        // Transform imports and add Debug derive
        let rect_transformed = rect_def
            .replace("use hotline::{", "use crate::{")
            .replace("#[derive(Clone)]", "#[derive(Clone, Debug)]");
        
        generated.push_str("pub mod rect {\n");
        generated.push_str(&rect_transformed);
        generated.push_str("\n}\n\n");
        
        // Write the generated file
        fs::write(&dest_path, generated).expect("Failed to write generated file");
        
        println!("cargo:rustc-env=MONOLITH_OBJECTS_PATH={}", dest_path.display());
    }
}